get seperate subroutines working
try mlevel for special case


*** PRIORITIES ***
Check equation is symmetric (might need to do steady state)
parallelise code - implement communication within jacobi and conjugate gradient module
set up solver for both conjugate gradient and normal - need to properly set up initial condition
get communication and solution initialisation sorted - for parallelisation
try to implement red-black jacobi solver

Implement local indices
Implement communication
Initialise variables with parallelisation
get it working with simple parallelisation independent of claras code and then implement claras variables
copy maxtest code into main.f90
need to get comms working in cg solver
copy comms into maxtest.f90
check i = il,ih and j = jl,jh arent going outside of matrix bounds
dot product in conjugate gradient


Conjugate gradient method
TO DO:
    Update preconditioning solver

QUESTIONS
    Where does the communication occur in the conjugate gradient method










 !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    ! subroutine to solve jacobi - completely serial atm
    SUBROUTINE jacobisolv(an,as,ae,aw,ap,b,x,y,T)

        IMPLICIT NONE
        ! Getting variables from varmod module
            ! nx - number of x points
            ! ny - number of y points
            ! dx - discretisation in x
            ! dy - discretisation in y
            ! dt - temporal discretisation
            ! dt - temporal discretisation
            ! alpha - thermal diffusivity
            ! t_final - total time

        ! Defining variables
        REAL(kind=8), INTENT(IN) :: an(nx,ny), as(nx,ny), ae(nx,ny), aw(nx,ny), ap(nx,ny), b(nx,ny), x(nx), y(ny)
        REAL(kind=8), INTENT(INOUT) :: T(nx,ny)

        Real(kind = 8) :: time, rcurrent
        Real(kind = 8) :: Tn(nx,ny), Told(nx,ny), res(nx,ny)
        Real(kind = 8) :: Minv(nx,ny)
        Integer :: i,j,iter, ii, il,jl,ih,jh

        ! Set code case for type of solver, norm - for jacobi solving, redblack - for redblack jacobi solver
        solving = "norm"

        !------------------------------------------------------------------------------------!
        !------------------------------------------------------------------------------------!

        ! Inititialising old temperature array
        Told(:,:) = 0

        ! Initialising time counter
        time = 0
        iter = 0

 
        ! Iteratively solving the jacobi equation
        ! Solving unsteady 2D Heat diffusion - dT/dt = alpha*(d^2T/dx^2 + d^2T/dy^2)

        SELECT CASE (solving)

            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            ! Jacobi solver
            CASE ("norm")
       
                ! do while ((t<ttot).and.(res>rmax))
                do while (time<t_final)
                    if (time == 0) then
                        do j = 2,(ny-1)
                        ! do j = jl,jh
                            do i = 2,(nx-1)
                            ! do i = il,ih
                                Tn(i,j) = (T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j))/2
                            end do
                        end do
                    else
                        do j = 2,(ny-1)
                        ! do j = jl,jh
                            do i = 2,(nx-1)
                            ! do i = il,ih
                                Tn(i,j) = T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j) - Told(i,j)
                            end do
                        end do
                    end if


                    ! COMMUNICATION


                    ! computing residuals
                    call residcalc(aw,ae,an,as,ap,b,T,res)

                    ! Calculate Domain averaged residual for stopping critterion
                    ! rcurrent = SUM(SUM(ABS(r(il:ih,jl:jh)),1),1) / ((kx-2)*(ky-2))
                    rcurrent = SUM(SUM(ABS(res(1:nx,1:ny)),1),1) / ((nx-2)*(ny-2))

                    if (mod(iter,100).eq.0) then
                        write(*,*) '      iter', '      res'
                        write(*,*) iter, rcurrent
                    end if

                    ! updating old and new temperature values
                    Told = T
                    T = Tn

                    ! updating counter
                    time = time + dt
                    iter = iter + 1

                end do

            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            ! red are odd nodes
            ! black are even nodes
            CASE ("redblack")

                ! do while ((t<ttot).and.(res>rmax))
                do while (time<t_final)
                    if (time == 0) then

                        ! RED NODES CALCULATION
                        do j = 2,(ny-1),2
                        ! do j = jl,jh,2
                            do i = 2,(nx-1),2
                            ! do i = il,ih,2
                                Tn(i,j) = (T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j))/2
                            end do
                        end do

                        ! RED NODES COMMUNICATION



                        !---------------------------------------------------------------!
                        !---------------------------------------------------------------!
                        ! BLACK NODES CALCULATION
                        do j = 3,(ny-1),2
                        ! do j = jl+1,jh,2
                            do i = 3,(nx-1),2
                            ! do i = il+1,ih,2
                                Tn(i,j) = (T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j))/2
                            end do
                        end do

                        ! BLACK NODES COMMUNICATION
                    else

                        ! RED NODES CALCULATION
                        do j = 2,(ny-1),2
                        ! do j = jl,jh,2
                            do i = 2,(nx-1),2
                            ! do i = il,ih,2
                                Tn(i,j) = T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j) - Told(i,j)
                            end do
                        end do

                        ! RED NODES COMMUNICATION



                        !---------------------------------------------------------------!
                        !---------------------------------------------------------------!
                        ! BLACK NODES CALCULATION
                        do j = 3,(ny-1),2
                        ! do j = jl+1,jh,2
                            do i = 3,(nx-1),2
                            ! do i = il+1,ih,2
                                Tn(i,j) = T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j) - Told(i,j)
                            end do
                        end do
                        
                        ! BLACK NODES COMMUNICATION

                    end if


                    ! computing residuals
                    call residcalc(aw,ae,an,as,ap,b,T,res)

                    ! Calculate Domain averaged residual for stopping critterion
                    ! rcurrent = SUM(SUM(ABS(r(il:ih,jl:jh)),1),1) / ((kx-2)*(ky-2))
                    rcurrent = SUM(SUM(ABS(res(1:nx,1:ny)),1),1) / ((nx-2)*(ny-2))

                    if (mod(iter,100).eq.0) then
                        write(*,*) '      iter', '      res'
                        write(*,*) iter, rcurrent
                    end if

                    ! updating old and new temperature values
                    Told = T
                    T = Tn

                    ! updating counter
                    time = time + dt
                    iter = iter + 1

                end do

            CASE DEFAULT 
                WRITE(*,*) "No solver selected or incorrect selection"
                STOP
	    END SELECT

        1600 FORMAT(5(F14.8,1x))

    END SUBROUTINE jacobisolv