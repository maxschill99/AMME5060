get seperate subroutines working
try mlevel for special case


*** PRIORITIES ***
Check equation is symmetric (might need to do steady state)
parallelise code - implement communication within jacobi and conjugate gradient module
set up solver for both conjugate gradient and normal - need to properly set up initial condition
get communication and solution initialisation sorted - for parallelisation
try to implement red-black jacobi solver

% MAIN %
set a constant boundary condition
change boundary conditions
fix residual using allreduce
work on conjugate gradient stuff
plot initial temp distribution
test for longer time period/smaller residual
need to update modules to remove redundancy

Implement local indices
Implement communication
Initialise variables with parallelisation
get it working with simple parallelisation independent of claras code and then implement claras variables
copy maxtest code into main.f90
need to get comms working in cg solver
copy comms into maxtest.f90
check i = il,ih and j = jl,jh arent going outside of matrix bounds
dot product in conjugate gradient


check over looping indices for residual
use new boundary condition


output tecplot from maxtest.f90


Conjugate gradient method
TO DO:
    Update preconditioning solver

QUESTIONS
    Where does the communication occur in the conjugate gradient method



	! if (pid .eq. 0) then
	! 	write(*,*) pid, "before comms"
	! 	call printmatrix(T, SIZE(T, DIM=1), SIZE(T, DIM=2))
	! end if
	! if (pid .eq. 1) then
	! 	write(*,*) pid, "before comms"
	! 	call printmatrix(T, SIZE(T, DIM=1), SIZE(T, DIM=2))
	! end if
	

	! SOLVER OUTLINE
		! outer loop: time stepping 
			! solve for time step n+1 and while r<err
				! conjugate gradient/jacobi/redback

				! this will involve looping through temperature arrays
				! end solve for timestep n+1

				! update resduals
			
			! If statement check that t=somevalue
			! WRITE TO ONE FILE 
			
		! end time stepping
		
		! Initialisation module
		! Residual module
		! Solver module - jacobi/red-black/Conjugate Gradient
		! Call communication

! ! JUST DOING MY OWN TECPLOT FILE WRITING
    ! ! Creating a temp array to combine all processor data
    ! ALLOCATE(Ttemp(resil:resih,resjl:resjh))

	! if (pid==0) then
		! allocate(Tinittot(nx,ny))
	! end if

    ! ! RUNNING A CHECK TO SEE IF INTIIAL TEMP IS BEING CALCULATED CORRECTLY
    ! Ttemp = T(resil:resih,resjl:resjh)

	! npp = nx/nprocs
    ! ! Gathering data to processor 1
    ! CALL MPI_GATHER(Ttemp,ny*npp,MPI_DOUBLE_PRECISION,Tinittot,ny*npp,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)

	! allocate(x(jl:jh))
	! allocate(y(il:ih))

	! ! x is in the j direction, y is in the i direction
	! do i = il,ih
		! y(i) = (i-1)*dy
	! end do
	! do j = jl,jh
		! x(j) = (j-1)*dx
	! end do

	! if (pid==0) then
		! write(*,1600) Tinittot

		! ! Writing updated initial distribution to file
        ! write(file_name, "(A14)") "Tecplotmax.tec"
        ! call tecplot_2D ( iunit, nx, ny, x, y, Tinittot, file_name )
	! end if

	! ! Computing residual matrix
	! call respar(aw,ae,an,as,ap,b,T,resil,resih,resjl,resjh,resmat)

	! ! Calculate Domain averaged residual for stopping critterion
	! rcurrent = SUM(SUM(ABS(resmat(resil:resih,resjl:resjh)),1),1) / ((resih-resil+1)*(resjh-resjl+1))
	! ! write(*,*) rcurrent, rc

	! ! ! Combining all residuals on each processor and sending to processor 0
	! call MPI_REDUCE(rcurrent,rc,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierr)

	! ! Getting global averaged residual
	! if (pid == 0) then
	! 	rc = rc/nprocs
	! end if

	! ! Sending out global residual to each processor
	! call MPI_BCAST(rc,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)


        if (time == 0) then
            do j = jl+1,jh-1
                do i = il+1,ih-1
                    Tn(i,j) = (T(i+1,j)*an(i,j) + T(i-1,j)*as(i,j) + T(i,j+1)*ae(i,j) &
                        + T(i,j-1)*aw(i,j) + T(i,j)*ap(i,j))/2
                end do
            end do
        else
            do j = jl+1,jh-1
                do i = il+1,ih-1
                    Tn(i,j) = T(i+1,j)*an(i,j) + T(i-1,j)*as(i,j) + T(i,j+1)*ae(i,j) &
                        + T(i,j-1)*aw(i,j) + T(i,j)*ap(i,j) - Told(i,j)
                end do
            end do
        end if




 !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    !-------------------------------------------------------------------------------------------!
    ! subroutine to solve jacobi - completely serial atm
    SUBROUTINE jacobisolv(an,as,ae,aw,ap,b,x,y,T)

        IMPLICIT NONE
        ! Getting variables from varmod module
            ! nx - number of x points
            ! ny - number of y points
            ! dx - discretisation in x
            ! dy - discretisation in y
            ! dt - temporal discretisation
            ! dt - temporal discretisation
            ! alpha - thermal diffusivity
            ! t_final - total time

        ! Defining variables
        REAL(kind=8), INTENT(IN) :: an(nx,ny), as(nx,ny), ae(nx,ny), aw(nx,ny), ap(nx,ny), b(nx,ny), x(nx), y(ny)
        REAL(kind=8), INTENT(INOUT) :: T(nx,ny)

        Real(kind = 8) :: time, rcurrent
        Real(kind = 8) :: Tn(nx,ny), Told(nx,ny), res(nx,ny)
        Real(kind = 8) :: Minv(nx,ny)
        Integer :: i,j,iter, ii, il,jl,ih,jh

        ! Set code case for type of solver, norm - for jacobi solving, redblack - for redblack jacobi solver
        solving = "norm"

        !------------------------------------------------------------------------------------!
        !------------------------------------------------------------------------------------!

        ! Inititialising old temperature array
        Told(:,:) = 0

        ! Initialising time counter
        time = 0
        iter = 0

 
        ! Iteratively solving the jacobi equation
        ! Solving unsteady 2D Heat diffusion - dT/dt = alpha*(d^2T/dx^2 + d^2T/dy^2)

        SELECT CASE (solving)

            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            ! Jacobi solver
            CASE ("norm")
       
                ! do while ((t<ttot).and.(res>rmax))
                do while (time<t_final)
                    if (time == 0) then
                        do j = 2,(ny-1)
                        ! do j = jl,jh
                            do i = 2,(nx-1)
                            ! do i = il,ih
                                Tn(i,j) = (T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j))/2
                            end do
                        end do
                    else
                        do j = 2,(ny-1)
                        ! do j = jl,jh
                            do i = 2,(nx-1)
                            ! do i = il,ih
                                Tn(i,j) = T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j) - Told(i,j)
                            end do
                        end do
                    end if


                    ! COMMUNICATION


                    ! computing residuals
                    call residcalc(aw,ae,an,as,ap,b,T,res)

                    ! Calculate Domain averaged residual for stopping critterion
                    ! rcurrent = SUM(SUM(ABS(r(il:ih,jl:jh)),1),1) / ((kx-2)*(ky-2))
                    rcurrent = SUM(SUM(ABS(res(1:nx,1:ny)),1),1) / ((nx-2)*(ny-2))

                    if (mod(iter,100).eq.0) then
                        write(*,*) '      iter', '      res'
                        write(*,*) iter, rcurrent
                    end if

                    ! updating old and new temperature values
                    Told = T
                    T = Tn

                    ! updating counter
                    time = time + dt
                    iter = iter + 1

                end do

            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            !ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
            ! red are odd nodes
            ! black are even nodes
            CASE ("redblack")

                ! do while ((t<ttot).and.(res>rmax))
                do while (time<t_final)
                    if (time == 0) then

                        ! RED NODES CALCULATION
                        do j = 2,(ny-1),2
                        ! do j = jl,jh,2
                            do i = 2,(nx-1),2
                            ! do i = il,ih,2
                                Tn(i,j) = (T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j))/2
                            end do
                        end do

                        ! RED NODES COMMUNICATION



                        !---------------------------------------------------------------!
                        !---------------------------------------------------------------!
                        ! BLACK NODES CALCULATION
                        do j = 3,(ny-1),2
                        ! do j = jl+1,jh,2
                            do i = 3,(nx-1),2
                            ! do i = il+1,ih,2
                                Tn(i,j) = (T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j))/2
                            end do
                        end do

                        ! BLACK NODES COMMUNICATION
                    else

                        ! RED NODES CALCULATION
                        do j = 2,(ny-1),2
                        ! do j = jl,jh,2
                            do i = 2,(nx-1),2
                            ! do i = il,ih,2
                                Tn(i,j) = T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j) - Told(i,j)
                            end do
                        end do

                        ! RED NODES COMMUNICATION



                        !---------------------------------------------------------------!
                        !---------------------------------------------------------------!
                        ! BLACK NODES CALCULATION
                        do j = 3,(ny-1),2
                        ! do j = jl+1,jh,2
                            do i = 3,(nx-1),2
                            ! do i = il+1,ih,2
                                Tn(i,j) = T(i+1,j)*ae(i,j) + T(i-1,j)*aw(i,j) + T(i,j+1)*an(i,j) &
                                    + T(i,j-1)*as(i,j) + T(i,j)*ap(i,j) - Told(i,j)
                            end do
                        end do
                        
                        ! BLACK NODES COMMUNICATION

                    end if


                    ! computing residuals
                    call residcalc(aw,ae,an,as,ap,b,T,res)

                    ! Calculate Domain averaged residual for stopping critterion
                    ! rcurrent = SUM(SUM(ABS(r(il:ih,jl:jh)),1),1) / ((kx-2)*(ky-2))
                    rcurrent = SUM(SUM(ABS(res(1:nx,1:ny)),1),1) / ((nx-2)*(ny-2))

                    if (mod(iter,100).eq.0) then
                        write(*,*) '      iter', '      res'
                        write(*,*) iter, rcurrent
                    end if

                    ! updating old and new temperature values
                    Told = T
                    T = Tn

                    ! updating counter
                    time = time + dt
                    iter = iter + 1

                end do

            CASE DEFAULT 
                WRITE(*,*) "No solver selected or incorrect selection"
                STOP
	    END SELECT

        1600 FORMAT(5(F14.8,1x))

    END SUBROUTINE jacobisolv